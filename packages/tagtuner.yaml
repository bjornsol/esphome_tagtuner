# ------------------------------------------------|
# TagTuner ESPHome core configuration file        | 
# ------------------------------------------------|

# WiFi and fallback configuration using secrets.yaml
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # Fallback AP when WiFi connection fails
  ap:
    ssid: ${name}
    password: !secret fallback_password

# Creates WiFi AP when can't connect, web interface for setup
captive_portal:

# Enable Improv via Serial for WiFi provisioning over USB
improv_serial:

# ESP32 specific configuration
esp32:
  variant: esp32s3
  board: lolin_s3_mini
  framework:
    type: esp-idf

# FOTA (Firmware Over The Air) configuration
ota:
  - platform: esphome

# Activate logging
logger:

# API to expose services to Home Assistant
api:
  services:
    # Write NFC tag services
    - service: write_music_tag
      variables:
        music_url: string
        music_info: string
      then:
        - light.turn_on:
            id: activity_led
            brightness: ${led_brightness}
            red: 100%
            green: 0%
            blue: 0%
        - lambda: |-
            auto message = new nfc::NdefMessage();
            std::string uri = "";
            std::string text = "";
            uri += music_url;
            text += music_info;

            // Strip ? and everything after
            size_t pos = uri.find('?');
            if (pos != std::string::npos) {
              uri = uri.substr(0, pos);
            }
        
            if ( !uri.empty() ) {
              message->add_uri_record(uri);
            }
            if ( !text.empty() ) {
              message->add_text_record(text);
            }
            id(pn532_board).write_mode(message);
        - wait_until:
            not:
              pn532.is_writing:
        - light.turn_off:
            id: activity_led

    # Write printing tag service
    - service: write_printing_tag
      variables:
        filename: string
        file_info: string
      then:
        - light.turn_on:
            id: activity_led
            brightness: ${led_brightness}
            red: 100%
            green: 0%
            blue: 0%
        - lambda: |-
            auto message = new nfc::NdefMessage();
            std::string uri = "file://";
            std::string text = "";
            uri += filename;
            text += file_info;
            if ( !filename.empty() ) {
              message->add_uri_record(uri);
            }
            if ( !file_info.empty() ) {
              message->add_text_record(text);
            }
            id(pn532_board).write_mode(message);
        - wait_until:
            not:
              pn532.is_writing:
        - light.turn_off:
            id: activity_led

    # Write color tag service
    - service: write_color_tag
      variables:
        color_code: string
        color_name: string
      then:
        - light.turn_on:
            id: activity_led
            brightness: ${led_brightness}
            red: 100%
            green: 0%
            blue: 0%
        - lambda: |-
            auto message = new nfc::NdefMessage();
            std::string uri = "color://";
            std::string text = "";
            uri += color_code;
            text += color_name;
            if ( !color_code.empty() ) {
              message->add_uri_record(uri);
            }
            if ( !text.empty() ) {
              message->add_text_record(text);
            }
            id(pn532_board).write_mode(message);
            ESP_LOGI("tagwriter", "Writing color tag: %s (%s)", uri.c_str(), text.c_str());
        - wait_until:
            not:
              pn532.is_writing:
        - light.turn_off:
            id: activity_led

# Main configuration
esphome:
  name: $name
  name_add_mac_suffix: false
  project:
    name: Stubbslie.TagTuner
    version: "1.0.0"
  on_boot:
    priority: -10
    then:
      - wait_until:
          api.connected:
      - logger.log: API is connected!
      - light.turn_on:
          id: activity_led
          brightness: ${led_brightness}
          red: 0%
          green: 0%
          blue: 100%
          flash_length: 500ms
      - switch.turn_on: led_enabled

# Global variables
globals:
  # NFC tag source type (uid/amusic/spotify/sonos/file/color/error)
  - id: source
    type: std::string
  # Media URL from tag
  - id: url
    type: std::string
  # Human readable info from tag
  - id: info
    type: std::string
  # Tag read success flag
  - id: read_success
    type: bool
    restore_value: no
    initial_value: 'false'
  # NFC tag UID
  - id: tag_uid
    type: std::string
  # Current volume (0.0 - 1.0), persisted across reboots
  - id: volume_level
    type: float
    restore_value: yes
    initial_value: '0.20'
  # Last tag media URL, persisted across reboots
  - id: last_played_url
    type: std::string
    restore_value: yes
    initial_value: ''
  # Last played media info, persisted across reboots
  - id: last_played_info
    type: std::string
    restore_value: yes
    initial_value: ''
  # Lambda result holder for simplified case handling
  - id: lambda_result
    type: std::string
  - id: last_scan_time
    type: unsigned long
    restore_value: no
    initial_value: '0'
  - id: rate_limit_ms
    type: unsigned long
    restore_value: no
    initial_value: '2000'

# Event handling scripts
script:
  - id: handle_tag_removed
    then:
      - text_sensor.template.publish:
          id: tagtune_status
          state: "tag removed"
      # Pause playback on tag removal for music tags
      - if:
          condition:
            lambda: 'return id(source) == "spotify" || id(source) == "amusic" || id(source) == "sonos";'
          then:
            - if:
                condition:
                  lambda: 'return ${pause_on_tag_remove};'
                then:
                  - logger.log:
                      format: "Tag removed - pausing: %s"
                      args: ['id(last_played_info).c_str()']
                  - if:
                      condition:
                        lambda: 'return !${ha_automation_events};'
                      then:
                        - if:
                            condition:
                              lambda: 'return ${area_not_player};'
                            then:
                              - homeassistant.service:
                                  service: media_player.media_pause
                                  data:
                                    area_id: ${area_entity}
                            else:
                              - homeassistant.service:
                                  service: media_player.media_pause
                                  data:
                                    entity_id: ${media_player_entity}
                      else:
                        - logger.log: "HA automations enabled - skipping media pause"
                else:
                  - logger.log: "Tag removed - pause on tag remove disabled, no action taken"
            - binary_sensor.template.publish:
                id: tag_present
                state: false
            - homeassistant.event:
                event: esphome.tag_removed
            - light.turn_off:
                id: activity_led
                transition_length: 0ms
      
          else: # Handle tag removal for non-music tags
            - logger.log: "Tag removed - no action taken for non-music tag"
            - binary_sensor.template.publish:
                id: tag_present
                state: false
            - homeassistant.event:
                event: esphome.tag_removed
  - id: handle_tag_read
    then:
      - if: # Handle LED action here: If rate limited, do nothing. Else, if read sucess, flash green. Else (read failure), flash red
        condition:
          lambda: 'return (id(lambda_result)!="rate_limited");'
        then:
        - if:
            condition:
              lambda: 'return id(read_success);'
            then:
            - light.turn_on:
                id: activity_led
                brightness: 100%
                red: 0%
                green: 100%
                blue: 0%
                flash_length: 500ms
            else:
            - light.turn_on:
                id: activity_led
                brightness: 100%
                red: 100%
                green: 0%
                blue: 0%
                flash_length: 500ms
        
      - if: # Lambda result = music tag
          condition:
            lambda: 'return (id(lambda_result)=="music_tag");'
          then:
          - homeassistant.event:
              event: esphome.music_tag
              data:
                reader: !lambda 'return App.get_name().c_str();'
                source: !lambda 'return id(source);'
                url: !lambda 'return id(url);'
                info: !lambda 'return id(info);'
          - if: # Play new URL or resume last played
            condition:
              lambda: 'return id(url) != id(last_played_url);'
            then:
              - logger.log: 
                  format: "New tag detected - playing: %s" 
                  args: ['id(info).c_str()']
              - if:
                  condition:
                    lambda: 'return !${ha_automation_events};'
                  then:
                    - if:
                        condition:
                          lambda: 'return ${area_not_player};'
                        then:
                          - homeassistant.service:
                              service: media_player.play_media
                              data:
                                area_id: ${area_entity}
                                media_content_type: music
                                media_content_id: !lambda 'return id(url);'
                        else:
                          - homeassistant.service:
                              service: media_player.play_media
                              data:
                                entity_id: ${media_player_entity}
                                media_content_type: music
                                media_content_id: !lambda 'return id(url);'
                  else:
                    - logger.log: "HA automations enabled - skipping play_media"
              - lambda: |-
                  id(last_played_url) = id(url);
                  id(last_played_info) = id(info);
            else:
              - logger.log: 
                  format: "Same tag resuming: %s" 
                  args: ['id(info).c_str()']
              - if:
                  condition:
                    lambda: 'return !${ha_automation_events};'
                  then:
                    - if:
                        condition:
                          lambda: 'return ${area_not_player};'
                        then:
                          - homeassistant.service:
                              service: media_player.media_play
                              data:
                                area_id: ${area_entity}
                        else:
                          - homeassistant.service:
                              service: media_player.media_play
                              data:
                                entity_id: ${media_player_entity}
                  else:
                    - logger.log: "HA automations enabled - skipping media_play"

      - if: # Lambda result = printing tag
          condition:
            lambda: 'return (id(lambda_result)=="printing_tag");'
          then:
          - homeassistant.event:
              event: esphome.print_tag
              data:
                reader: !lambda 'return App.get_name().c_str();'
                source: !lambda 'return id(source);'
                url: !lambda 'return id(url).erase(0,7);' # erasing 'file://'
                info: !lambda 'return id(info);'

      - if: # Lambda result = color tag
          condition:
            lambda: 'return (id(lambda_result)=="color_tag");'
          then:
          - homeassistant.event:
              event: esphome.color_tag
              data:
                reader: !lambda 'return App.get_name().c_str();'
                source: !lambda 'return id(source);'
                url: !lambda 'return id(url).erase(0,8);' # erasing 'color://'
                info: !lambda 'return id(info);'
  

# Switch to enable/disable activity LED
switch:
  # Enable/disable activity LED
  - platform: template
    name: "${friendly_name} LED Enabled"
    id: led_enabled
    icon: mdi:alarm-light-outline
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    entity_category: config

# Exposing cancel write and restart button to Home Assistant
button:
  # Cancel writing action
  - platform: template
    name: "${friendly_name} Cancel Writing"
    id: cancel_writing
    icon: mdi:pencil-off
    on_press:
      then:
        - lambda: 'id(pn532_board).read_mode();'
        - light.turn_off:
            id: activity_led
  # Restart device button
  - platform: restart
    name: "${friendly_name} Restart"
    entity_category: config

# Setup of PN532 NFC reader over SPI
spi:
  clk_pin: $spi_clk_pin
  miso_pin: $spi_miso_pin
  mosi_pin: $spi_mosi_pin

# PN532 NFC reader over SPI
pn532_spi:
  cs_pin: $spi_cs_pin
  id: pn532_board
  update_interval: 200ms
  on_tag:
    then:
      #- delay: 0.15s #to fix slow component
      - binary_sensor.template.publish:
          id: tag_present
          state: true
      - lambda: |-
          id(read_success) = false;
          id(source)="uid";
          id(url)="";
          id(info)="";
          id(tag_uid) = x; // Store UID in global variable
          if (tag.has_ndef_message()) {
            auto message = tag.get_ndef_message();
            auto records = message->get_records();
            const char *applemusic_prefix="https://music.apple.com";
            const char *spotify_prefix="https://open.spotify.com";
            const char *sonos_prefix="sonos-2://";
            const char *printfile_prefix="file://";
            const char *colortag_prefix="color://";
            for (auto &record : records) {
              auto &payload = record->get_payload();
              auto &type = record->get_type();

              if (type == "U"){
                id(url)=payload;
                id(read_success) = true;
                if (payload.compare(0, strlen(applemusic_prefix), applemusic_prefix)==0){
                  ESP_LOGD("tagreader", "Found Apple Music tag NDEF");
                  id(source)="amusic";
                  id(lambda_result)="music_tag";
                }
                else if (payload.compare(0, strlen(spotify_prefix), spotify_prefix)==0){
                  ESP_LOGD("tagreader", "Found Spotify tag NDEF");
                  id(source)="spotify";
                  id(lambda_result)="music_tag";
                }
                else if (payload.compare(0, strlen(sonos_prefix), sonos_prefix)==0){
                  ESP_LOGD("tagreader", "Found Sonos app tag NDEF");
                  id(source)="sonos";
                  id(lambda_result)="music_tag";
                }
                else if (payload.compare(0, strlen(printfile_prefix), printfile_prefix)==0){
                  ESP_LOGD("tagreader", "Found print tag NDEF");
                  id(source)="file";
                  id(lambda_result)="print_tag";
                }
                else if (payload.compare(0, strlen(colortag_prefix), colortag_prefix)==0){
                  ESP_LOGD("tagreader", "Found color tag NDEF");
                  id(source)="color";
                  id(lambda_result)="color_tag";
                }
              }
              else if (type == "T" ) {
                ESP_LOGD("tagreader", "Found info tag NDEF");
                id(info)=payload;
              }
            }
          }
          else {
            id(source)="error";
          }
      - script.execute: handle_tag_read
  on_tag_removed:
    then:
      - script.execute: handle_tag_removed

# Expose status and tag presence to Home Assistant
binary_sensor:
  # TagTuner status
  - platform: status
    name: "${friendly_name} Status"
    entity_category: diagnostic
  # Presence of an NFC tag
  - platform: template
    name: "${friendly_name} Tag Present"
    id: tag_present
    device_class: occupancy
    icon: mdi:nfc

# Expose useful info to Home Assistant diagnostics
text_sensor:
  # ESPHome version
  - platform: version
    hide_timestamp: true
    name: "${friendly_name} ESPHome Version"
    entity_category: diagnostic
  # WiFi info
  - platform: wifi_info
    ip_address:
      name: "${friendly_name} IP Address"
      icon: mdi:wifi
      entity_category: diagnostic
    ssid:
      name: "${friendly_name} Connected SSID"
      icon: mdi:wifi-strength-2
      entity_category: diagnostic
  # TagTuner status
  - platform: template
    id: tagtune_status
    name: "${friendly_name} Status"
    icon: mdi:ladybug
    entity_category: diagnostic

# WS2812 RGB Activity LED for visual feedback
light:
  - platform: esp32_rmt_led_strip
    chipset: ws2812
    pin: $light_pin
    num_leds: 1
    flash_transition_length: 200ms
    rgb_order: GRB
    id: activity_led
    name: "${friendly_name} LED"
    restore_mode: ALWAYS_OFF

