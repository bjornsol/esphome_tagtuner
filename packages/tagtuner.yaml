# ------------------------------------------------|
# TagTuner ESPHome core configuration file        | 
# ------------------------------------------------|

# WiFi and fallback configuration using secrets.yaml
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # Fallback AP when WiFi connection fails
  ap:
    ssid: ${name}
    password: !secret fallback_password

# Creates WiFi AP when can't connect, web interface for setup
captive_portal:

# Enable Improv via Serial for WiFi provisioning over USB
improv_serial:

# ESP32 specific configuration
esp32:
  variant: esp32s3
  board: lolin_s3_mini
  framework:
    type: esp-idf

# FOTA (Firmware Over The Air) configuration
ota:
  - platform: esphome

# Activate logging
logger:

# API to expose services to Home Assistant
api:
  services:
  # Write NFC tag services
  - service: write_music_tag
    variables:
      music_url: string
      music_info: string
    then:
    - light.turn_on:
        id: activity_led
        brightness: ${led_brightness}
        red: 100%
        green: 0%
        blue: 0%
    - lambda: |-
        auto message = new nfc::NdefMessage();
        std::string uri = "";
        std::string text = "";
        uri += music_url;
        text += music_info;

        // Strip ? and everything after
        size_t pos = uri.find('?');
        if (pos != std::string::npos) {
          uri = uri.substr(0, pos);
        }
    
        if ( !uri.empty() ) {
          message->add_uri_record(uri);
        }
        if ( !text.empty() ) {
          message->add_text_record(text);
        }
        id(pn532_board).write_mode(message);
    - wait_until:
        not:
          pn532.is_writing:
    - light.turn_off:
        id: activity_led

  # Write printing tag service
  - service: write_printing_tag
    variables:
      filename: string
      file_info: string
    then:
    - light.turn_on:
        id: activity_led
        brightness: ${led_brightness}
        red: 100%
        green: 0%
        blue: 0%
    - lambda: |-
        auto message = new nfc::NdefMessage();
        std::string uri = "file://";
        std::string text = "";
        uri += filename;
        text += file_info;
        if ( !filename.empty() ) {
          message->add_uri_record(uri);
        }
        if ( !file_info.empty() ) {
          message->add_text_record(text);
        }
        id(pn532_board).write_mode(message);
    - wait_until:
        not:
          pn532.is_writing:
    - light.turn_off:
        id: activity_led

  # Write color tag service
  - service: write_color_tag
    variables:
      color_code: string
      color_name: string
    then:
    - light.turn_on:
        id: activity_led
        brightness: ${led_brightness}
        red: 100%
        green: 0%
        blue: 0%
    - lambda: |-
        auto message = new nfc::NdefMessage();
        std::string uri = "color://";
        std::string text = "";
        uri += color_code;
        text += color_name;
        if ( !color_code.empty() ) {
          message->add_uri_record(uri);
        }
        if ( !text.empty() ) {
          message->add_text_record(text);
        }
        id(pn532_board).write_mode(message);
        ESP_LOGI("tagwriter", "Writing color tag: %s (%s)", uri.c_str(), text.c_str());
    - wait_until:
        not:
          pn532.is_writing:
    - light.turn_off:
        id: activity_led

# Main configuration
esphome:
  name: $name
  name_add_mac_suffix: false
  project:
    name: Stubbslie.TagTuner
    version: "1.0.0"
  on_boot:
    priority: -10
    then:
      - wait_until:
          api.connected:
      - logger.log: API is connected!
      - light.turn_on:
          id: activity_led
          brightness: ${led_brightness}
          red: 0%
          green: 0%
          blue: 100%
          flash_length: 500ms
      - switch.turn_on: led_enabled

# Global variables
globals:
  # NFC tag source type (uid/amusic/spotify/sonos/file/color/error)
  - id: source
    type: std::string
  # Media URL from tag
  - id: url
    type: std::string
  # Human readable info from tag
  - id: info
    type: std::string
  # Tag read success flag
  - id: read_success
    type: bool
    restore_value: no
    initial_value: 'false'
  # NFC tag UID
  - id: tag_uid
    type: std::string
  # Current volume (0.0 - 1.0), persisted across reboots
  - id: volume_level
    type: float
    restore_value: yes
    initial_value: '0.20'
  # Last tag media URL, persisted across reboots
  - id: last_played_url
    type: std::string
    restore_value: yes
    initial_value: ''
  # Last played media info, persisted across reboots
  - id: last_played_info
    type: std::string
    restore_value: yes
    initial_value: ''

# Event handling scripts
script:
  - id: handle_tag_removed
    then:
      - text_sensor.template.publish:
          id: tagtune_status
          state: "tag removed"
      # Pause playback on tag removal for music tags
      - if:
          condition:
              lambda: 'return id(source) == "spotify" || id(source) == "amusic" || id(source) == "sonos";'
          then:
            - logger.log:
                format: "Tag removed - pausing: %s"
                args: ['id(last_played_info).c_str()']
            - homeassistant.service:
                service: media_player.media_pause
                data:
                  entity_id: ${media_player_entity}
            - binary_sensor.template.publish:
                id: tag_present
                state: false
            - homeassistant.event:
                event: esphome.tag_removed
            - light.turn_off:
                id: activity_led
                transition_length: 0ms
      # Handle tag removal for non-music tags
          else:
            - logger.log: "Tag removed - no action taken for non-music tag"
            - binary_sensor.template.publish:
                id: tag_present
                state: false
            - homeassistant.event:
                event: esphome.tag_removed
  - id: handle_tag_read
    then:
      - text_sensor.template.publish:
          id: tagtune_status
          state: "tag read"
      # Visual feedback on tag read success/failure
      - if:
          condition:
            lambda: 'return id(read_success);'
          then:
            - light.turn_on:
                id: activity_led
                brightness: ${led_brightness}
                red: 0%
                green: 100%
                blue: 0%
          else:
            - light.turn_on:
                id: activity_led
                brightness: ${led_brightness}
                red: 100%
                green: 0%
                blue: 0%
                flash_length: 500ms
      - if:
          condition:
            lambda: 'return ( id(source)=="uid" || id(source)=="error" );'
          then:
            - homeassistant.tag_scanned: !lambda |-
                ESP_LOGD("tagreader", "No HA NDEF, using UID");
                return id(tag_uid); // Use the stored UID;
          # Handle tag based on source type
          else:
          # Print tag event
            - if:
                condition:
                  lambda: 'return ( id(source)=="file" );'
                then:
                  - homeassistant.event:
                      event: esphome.print_tag
                      data:
                        reader: !lambda 'return App.get_name().c_str();'
                        source: !lambda 'return id(source);'
                        url: !lambda 'return id(url).erase(0,7);' # erasing 'file://'
                        info: !lambda 'return id(info);'
                  - light.turn_off:
                      id: activity_led
                else:
                # Color tag event
                - if:
                    condition:
                        lambda: 'return ( id(source)=="color" );'
                    then:
                      - homeassistant.event:
                          event: esphome.color_tag
                          data:
                            reader: !lambda 'return App.get_name().c_str();'
                            source: !lambda 'return id(source);'
                            url: !lambda 'return id(url).erase(0,8);' # erasing 'color://'
                            info: !lambda 'return id(info);'
                      - light.turn_off:
                          id: activity_led
                  else:
                    # Music tag (Apple Music, Spotify, Sonos)
                    - homeassistant.event:
                        event: esphome.music_tag
                        data:
                          reader: !lambda 'return App.get_name().c_str();'
                          source: !lambda 'return id(source);'
                          url: !lambda 'return id(url);'
                          info: !lambda 'return id(info);'
                      
                    # Play new URL or resume last played
                    - if:
                          condition:
                            lambda: 'return id(url) != id(last_played_url);'
                          then:
                            - logger.log: 
                                format: "New tag detected - playing: %s" 
                                args: ['id(info).c_str()']
                            - homeassistant.service:
                                service: media_player.play_media
                                data:
                                  entity_id: ${media_player_entity}
                                  media_content_type: music
                                  media_content_id: !lambda 'return id(url);'
                            - lambda: |-
                                id(last_played_url) = id(url);
                                id(last_played_info) = id(info);
                          else:
                            - logger.log: 
                                format: "Same tag resuming: %s" 
                                args: ['id(info).c_str()']
                            - homeassistant.service:
                                service: media_player.media_play
                                data:
                                  entity_id: ${media_player_entity}

# Switch to enable/disable activity LED
switch:
  # Enable/disable activity LED
  - platform: template
    name: "${friendly_name} LED Enabled"
    id: led_enabled
    icon: mdi:alarm-light-outline
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    entity_category: config

# Exposing cancel write and restart button to Home Assistant
button:
  # Cancel writing action
  - platform: template
    name: "${friendly_name} Cancel Writing"
    id: cancel_writing
    icon: mdi:pencil-off
    on_press:
      then:
        - lambda: 'id(pn532_board).read_mode();'
        - light.turn_off:
            id: activity_led
  # Restart device button
  - platform: restart
    name: "${friendly_name} Restart"
    entity_category: config

# Setup of PN532 NFC reader over SPI
spi:
  clk_pin: $spi_clk_pin
  miso_pin: $spi_miso_pin
  mosi_pin: $spi_mosi_pin

# PN532 NFC reader over SPI
pn532_spi:
  cs_pin: $spi_cs_pin
  id: pn532_board
  update_interval: 200ms
  on_tag:
    then:
      #- delay: 0.15s #to fix slow component
      - binary_sensor.template.publish:
          id: tag_present
          state: true
      - lambda: |-
          id(read_success) = false;
          id(source)="uid";
          id(url)="";
          id(info)="";
          id(tag_uid) = x; // Store UID in global variable
          if (tag.has_ndef_message()) {
            auto message = tag.get_ndef_message();
            auto records = message->get_records();
            const char *applemusic_prefix="https://music.apple.com";
            const char *spotify_prefix="https://open.spotify.com";
            const char *sonos_prefix="sonos-2://";
            const char *printfile_prefix="file://";
            const char *colortag_prefix="color://";
            for (auto &record : records) {
              auto &payload = record->get_payload();
              auto &type = record->get_type();

              if (type == "U"){
                id(url)=payload;
                id(read_success) = true;
                if (payload.compare(0, strlen(applemusic_prefix), applemusic_prefix)==0){
                  ESP_LOGD("tagreader", "Found Apple Music tag NDEF");
                  id(source)="amusic";
                }
                else if (payload.compare(0, strlen(spotify_prefix), spotify_prefix)==0){
                  ESP_LOGD("tagreader", "Found Spotify tag NDEF");
                  id(source)="spotify";
                }
                else if (payload.compare(0, strlen(sonos_prefix), sonos_prefix)==0){
                  ESP_LOGD("tagreader", "Found Sonos app tag NDEF");
                  id(source)="sonos";
                }
                else if (payload.compare(0, strlen(printfile_prefix), printfile_prefix)==0){
                  ESP_LOGD("tagreader", "Found print tag NDEF");
                  id(source)="file";
                }
                else if (payload.compare(0, strlen(colortag_prefix), colortag_prefix)==0){
                  ESP_LOGD("tagreader", "Found color tag NDEF");
                  id(source)="color";
                }
              }
              else if (type == "T" ) {
                ESP_LOGD("tagreader", "Found info tag NDEF");
                id(info)=payload;
              }
            }
          }
          else {
            id(source)="error";
          }
      - script.execute: handle_tag_read
  on_tag_removed:
    then:
      - script.execute: handle_tag_removed

# Expose status and tag presence to Home Assistant
binary_sensor:
  # TagTuner status
  - platform: status
    name: "${friendly_name} Status"
    entity_category: diagnostic
  # Presence of an NFC tag
  - platform: template
    name: "${friendly_name} Tag Present"
    id: tag_present
    device_class: occupancy
    icon: mdi:nfc

# Expose useful info to Home Assistant diagnostics
text_sensor:
  # ESPHome version
  - platform: version
    hide_timestamp: true
    name: "${friendly_name} ESPHome Version"
    entity_category: diagnostic
  # WiFi info
  - platform: wifi_info
    ip_address:
      name: "${friendly_name} IP Address"
      icon: mdi:wifi
      entity_category: diagnostic
    ssid:
      name: "${friendly_name} Connected SSID"
      icon: mdi:wifi-strength-2
      entity_category: diagnostic
  # TagTuner status
  - platform: template
    id: tagtune_status
    name: "${friendly_name} Status"
    icon: mdi:ladybug
    entity_category: diagnostic

# WS2812 RGB Activity LED for visual feedback
light:
  - platform: esp32_rmt_led_strip
    chipset: ws2812
    pin: $light_pin
    num_leds: 1
    flash_transition_length: 200ms
    rgb_order: GRB
    id: activity_led
    name: "${friendly_name} LED"
    restore_mode: ALWAYS_OFF

